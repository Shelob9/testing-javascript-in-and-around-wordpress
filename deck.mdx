import { Appear, Head, Image } from "mdx-deck";
import { FullScreenCode, Invert } from "mdx-deck/layouts";
import SyntaxHighlighter from "react-syntax-highlighter/prism";
import { atomLight, atomDark } from "react-syntax-highlighter/styles/prism";
export { dark as theme } from "mdx-deck/themes";

<Head>
  <title>Presentation Title</title>
  <meta property="og:description" content="Presentation description" />
  <meta property="og:site_name" content="Presentation Title" />
  <meta property="article:published_time" content="2013-09-17T05:59:00+01:00" />
  <meta property="article:modified_time" content="2013-09-16T19:08:47+01:00" />
  <meta property="article:section" content="Article Section (React? Design?)" />
</Head>

<Image
  src='https://images.unsplash.com/photo-1559369625-a3deda175816?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80'
  style={{
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'white',
    backgroundColor: 'black',
  }}>

# JavaScript Testing In And Aroung WordPress

</Image>

---

<Image
  src="https://pbs.twimg.com/profile_images/1044050165269766149/YyCvrqoN_400x400.jpg"
  style={{
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "white",
    backgroundColor: "black"
  }}
>
  <h2>Hi I'm Josh</h2>
  <ul>
    <li>
      <a href="https://JoshPress.net">JoshPress.net</a>
    </li>
    <li>
      <a href="https://Twitter.com/Josh412">@josh412</a>
    </li>
  </ul>
</Image>

---

## Types Of Tests

---

# Types Of Tests: Unit Tests

Does A Component Work In Isolation?

---

# Types Of Tests: Integration Tests

AKA - Feature Tests

Do The Components Work Together?

---

# Types Of Tests: Acceptance Tests

AKA - End to End Tests
AKA - e2e Tests

Does the whole system work together?

---

# JavaScript Testing In And Around WordPress

## Part One: Testing React Apps

---

# How React Works

---

## Step 1

React creates an object representation of nodes representing a user interface.

- It does not produce HTML.

---

## Step 2

A "renderer" converts that object to a useable interface.

- ReactDOM renders React as DOM tree and appended to DOM.
- ReactDOMServer renders to an HTML string for server to send to client.

---

# Test Renderers

- React Test Renderer
- React Testing Library
- Enzyme

---

# The Test Suite

- Test Runner (Jest)
  - Runs the tests
- Test Renderer (react-test-library)
  - Creates and inspects output
- Assertions (Chai)
  - Tests the output

---

# Zero-Config Testing (and more)

- react-scripts
  - `react-scripts test`
- @wordpress/scripts
  - `wordpress-scripts test`

---

`npx create-react-app`

# Let's Write Some Tests

And A Web App :)

---

# Create A React App

<SyntaxHighlighter
  language="bash"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
# install create-react-app
npx create-react-app
# Run the included test
yarn test
  `}
</SyntaxHighlighter>

---

## Section

Create React App comes with one test.

This is an acceptance test. It tests if **anything** is broken.

---

## Test The App Renders

<SyntaxHighlighter
  language="bash"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<App />, div);
  ReactDOM.unmountComponentAtNode(div);
});
`}

</SyntaxHighlighter>

---

# Questions To Ask?

- How do I know the components works?
  - Unit tests
- How do I know the components work together?
  - Integration/ Feature Tests
- What is the most realistic test of the program?
  - Acceptance/ e2e Tests

---

# App Spec

Create a one page app that:

- Displays a value
- Has an input to change that value

---

# Test Spec

- Unit tests:
  - Does display component display the supplied value?
  - Does edit callback display the value
  - Does the edit component supply updated value to onChange callback?

---

# Test Spec

- Integration Tests:
  - Does the display value change with the input?

---

# Layout Of Our Test File

---

## `test()` Syntax

```jsx
//Import React
import React from "react";
//Import test renderer
import TestRenderer from "react-test-renderer";
//Import component to test
import { DisplayValue } from "./DisplayValue";

test("Component renders value", () => {});

test("Component has supplied class name", () => {});
```

---

## BDD style

```jsx
describe("EditValue component", () => {
  //Shared mock onChange function
  let onChange = jest.fn();
  beforeEach(() => {
    //Reset onChange mock before each test.
    onChange = jest.fn();
  });

  it("Has the supplied value in the input", () => {});

  it("id and for attribute match", () => {});

  it("Passes string to onChange when changed", () => {});

  it("Passes string to onChange when changed with an integer", () => {});
});
```

---

# Install React Test Renderer

<SyntaxHighlighter
  language="bash"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
yarn add react-test-renderer
  `}
</SyntaxHighlighter>

---

# Unit Testing React Components

---

## Find Props

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
test( 'Component renders value', () => {
    const value = 'The Value';
    const testRenderer = TestRenderer.create(<DisplayValue value={value} />);
    const testInstance = testRenderer.root;
    expect(testInstance.findByType('div').props.children).toBe(value);
});
`}

</SyntaxHighlighter>

---

## Do This For Every Prop?

### That Is Testing React, Not Your Application

---

## Snapshot Testing

### Renders Component To JSON

Stores JSON in file system

---

## Snapshot Testing

- Snapshots Acomplish Two Things:

  - Make sure your props went to the right places.
  - Force your to **commit** to changes.

---

## Create A Snapshot Test

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
test( 'Component renders correctly', () => {
    expect(
        TestRenderer.create(
            <DisplayValue
                value={'The Value'}
                className={'the-class-name'}
             />
        ).toJSON()
    ).toMatchSnapshot();
});
`}
</SyntaxHighlighter>

---

# Testing Events

React testing library is best for this. Enzyme is an alternative.

<SyntaxHighlighter
  language="bash"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
yarn add @testing-library/react
  `}
</SyntaxHighlighter>

---

## Test On Change Event

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
describe("EditValue component", () => {
    afterEach(cleanup);
    it("Calls the onchange function", () => {
        const onChange = jest.fn();
        const { getByTestId } = render(
          <EditValue 
            onChange={onChange} 
            value={""} 
            id={'input-test'}
            className={"some-class"}  
          />);
        fireEvent.change(getByTestId("input-test"), {
            target: { value: "New Value" }
        });
        expect(onChange).toHaveBeenCalledTimes(1);
    });
    //...
});
`}

</SyntaxHighlighter>

---

## Test On Change Event

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
describe("EditValue component", () => {
    afterEach(cleanup);
    //...
    it("Passes updated value, not event to onChange callback", () => {
        const onChange = jest.fn();
        const { getByTestId } = render(
          <EditValue 
            onChange={onChange} 
            value={""}
             id="input-test" 
             className={"some-class"}  
          />);
        fireEvent.change(getByTestId("input-test"), {
            target: { value: "New Value" }
        });
        expect(onChange).toHaveBeenCalledWith("New Value");
    });
});
`}

</SyntaxHighlighter>

---

# Snapshot Testing

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
describe("EditValue component", () => {
    afterEach(cleanup);
     it( 'matches snapshot', () => {
        expect( 
          render(
            <EditValue 
              onChange={jest.fn()} 
              value={"Hi Roy"}
              id={'some-id'} 
              className={"some-class"}
            /> 
          )
        ).toMatchSnapshot();
    });
});
`}

</SyntaxHighlighter>

---

# Integration Tests

Do the two components work together as expected?

---

## Integration Test

<SyntaxHighlighter
  language="javascript"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
it( 'Displays the updated value when value changes', () => {
    const { container,getByTestId } = render(<App  />)
    expect(container.querySelector('.display-value').textContent).toBe('Hi Roy');
    fireEvent.change(getByTestId("the-input"), {
        target: { value: "New Value" }
    });
    expect(container.querySelector('.display-value').textContent).toBe('New Value');
});
`}

</SyntaxHighlighter>

---

# JavaScript Testing In And Around WordPress

## Part Two: Testing Gutenberg Blocks

---

`yarn add @wordpress/scripts`

# Let's Write Some Tests

And A Plugin

---

# Spec

A block for showing some text.

- The components for the app should be reused.
- The block preview and rendered content should be identical.
- The control for the value should appear in the block’s inspector controls.

---

# Test Spec

## Integration Test

Will Gutenberg be able to manage our component’s state?

---

# Test Spec

## e2e Test

Does our plugin activate without errors?

Does our block appear in the block chooser?

---

# What Is `@wordpress/scripts` ??

- React-scripts inspired zero-config build tool for WordPress plugins with blocks.
- Provides:
  - Compilers
  - Linters
  - Test runner
  - e2e tests
  - Local development

---

# Setting Up Plugin For Testing

## Install WordPress scripts

<SyntaxHighlighter
  language="bash"
  style={atomLight}
  customStyle={{ minWidth: "500px" }}
>
  {`
# Install WordPress scripts
yarn add @wordpress/scripts
  `}
</SyntaxHighlighter>

---

## Add Scripts To package.json

See [README](https://www.npmjs.com/package/@wordpress/scripts)

```json
{
  "scripts": {
    "build": "wp-scripts build",
    "start": "wp-scripts start",
    "test:e2e": "wp-scripts test-e2e --config e2e/jest.config.js",
    "test:unit": "wp-scripts test-unit-js --config jest.config.js",
    "env:start": "bash start.sh"
  }
}
```

---

## Jest Is The Test Runner

Nothing new to learn.

# Structure Block For Easy Testing

- The file that builds the block to do nothing but build the block.

---

# The Block

```jsx
import { registerBlockType } from "@wordpress/blocks";
import { Editor } from "./components/Editor";
import { Save } from "./components/Save";
const blockConfig = require("../block.json");
const { name, title, attributes, category, keywords } = blockConfig;

registerBlockType(name, {
  title,
  attributes,
  category,
  keywords,
  edit: props => <Editor {...props} />,
  save: props => <Save {...props} />
});
```

---

## Edit And Save Callbacks

The edit and save callback are composed in separate files, importing components built for the app.

---

### Edit Callback

```jsx
import React, { Fragment } from "react";
import { EditValue } from "./app/EditValue";
import { DisplayValue } from "./app/DisplayValue";
import { InspectorControls } from "@wordpress/block-editor";
export const Editor = ({ attributes, setAttributes, className, clientId }) => {
  //Change handler
  const onChange = value => setAttributes({ value });
  //current value
  const { value } = attributes;
  return (
    <Fragment>
      <InspectorControls>
        <EditValue
          className={`${className}-editor`}
          id={clientId}
          value={value}
          onChange={onChange}
        />
      </InspectorControls>
      <DisplayValue value={value} className={className} />
    </Fragment>
  );
};
```

---

### Test Edit Callback

```jsx
//Import React
import React from "react";
//Import test renderer
import { render, fireEvent, cleanup } from "@testing-library/react";
//Import component to test
import { Editor } from "./Editor";

describe("Editor componet", () => {
  afterEach(cleanup);

  it("matches snapshot", () => {
    const attributes = { value: "Hi Roy" };
    const setAttributes = jest.fn();

    const props = {
      attributes,
      setAttributes,
      clientId: "random-id",
      className: "wp-blocks-whatever"
    };
    expect(render(<Editor {...props} />)).toMatchSnapshot();
  });
});
```

---

### Save Callback:

```jsx
import React from "react";
import { DisplayValue } from "./app/DisplayValue";
export const Save = ({ attributes, className }) => {
  return <DisplayValue value={attributes.value} className={className} />;
};
```

---

### Test Save Callback

```jsx
//Import React
import React from "react";
//Import test renderer
import { render, cleanup } from "@testing-library/react";
//Import component to test
import { Save } from "./Save";

describe("Save componet", () => {
  afterEach(cleanup);

  it("matches snapshot", () => {
    const attributes = { value: "Hi Roy" };

    const props = {
      attributes,
      clientId: "random-id",
      className: "wp-blocks-whatever"
    };
    expect(render(<Save {...props} />)).toMatchSnapshot();
  });
});
```

---

# End To End Testing Gutenberg Blocks

- Assuming that all of the components work, does the program function as expected.
- Test as a user.

---

## How To Setup Up WordPress End To End Tests

To make things easier, add the WordPress e2e test utilities:

```bash
# Add e2e test utilities
yarn add @wordpress/e2e-test-utils
```

---

### Configure Jest

I don't have time for this.

[Example You Can Copy]()

This is based on [WordPress core's e2e tests](https://github.com/WordPress/wordpress-develop/tree/master/tests/e2e)

---

### Uses Puppetter To Automate Chrome

You must have WordPress running locally with Docker.

You need to have Chromium headless installed.

The local development environment in example code works for this.

---

### Test That Block Works

```js
import {
  insertBlock,
  getEditedPostContent,
  createNewPost,
  activatePlugin
} from "@wordpress/e2e-test-utils";
```

---

### Test That Block Works

```jsx
describe("Block", () => {
  beforeEach(async () => {
    await activatePlugin("josh-jswp/josh-jswp.php");
  });

  it("Can add block", async () => {
    await createNewPost();
    await insertBlock("Josh Block");

    expect(await getEditedPostContent()).toMatchSnapshot();
  });
});
```

---

### Do NOT e2e Test Everything

e2e tests ensure that the system works toghether.

They are a compliment to less expensive unit/ inegration tests.

---

<h3>Links Related To WordPress e2e Tests</h3>

<ul>
  <li>
    {" "}
    <a href="https://make.wordpress.org/core/2019/06/27/introducing-the-wordpress-e2e-tests/">
      https://make.wordpress.org/core/2019/06/27/introducing-the-wordpress-e2e-tests/
    </a>{" "}
  </li>
  <li>
    {" "}
    <a href="https://developer.wordpress.org/block-editor/packages/packages-scripts/">
      https://developer.wordpress.org/block-editor/packages/packages-scripts/
    </a>{" "}
  </li>
</ul>

---

# 🤷 Any Questions? 🤷

* Slides: [🤷]